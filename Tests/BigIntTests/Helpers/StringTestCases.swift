//===--- StringTestCases.swift --------------------------------*- swift -*-===//
//
// This source file is part of the Swift Numerics open source project
//
// Copyright (c) 2023 Apple Inc. and the Swift Numerics project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
//
//===----------------------------------------------------------------------===//

import BigIntModule

// swiftlint:disable nesting
// swiftlint:disable number_separator
// swiftformat:disable numberFormatting

// The actual test cases are generated by Python script.
internal enum StringTestCases {

  internal struct TestSuite {
    internal let radix: Int
    internal let cases: [TestCase]
  }

  /// Single test case, always positive.
  internal struct TestCase {

    internal typealias Word = BigIntPrototype.Word

    /// Least significant word is at index `0`.
    /// Empty means `0`.
    private let magnitude: [Word]
    /// String representation with a certain base.
    internal let string: String

    internal var isZero: Bool {
      return self.magnitude.isEmpty
    }

    /// Insert `_` into `self.string`.
    internal var stringWithUnderscores: String {
      // We could create a pseudo-random algorithm to select underscore location.
      // Or we could just insert underscore after every 3rd digit.
      let underscoreAfterEvery = 3
      let s = self.string

      var result = ""
      result.reserveCapacity(s.count + s.count / underscoreAfterEvery)

      for (index, char) in s.enumerated() {
        assert(char != "_")
        result.append(char)

        // Suffix underscore is prohibited.
        let shouldHaveUnderscore = index.isMultiple(of: underscoreAfterEvery)
        let isLast = index == s.count - 1

        if shouldHaveUnderscore && !isLast {
          result.append("_")
        }
      }

      return result
    }

    internal init(_ magnitude: [Word], _ string: String) {
      self.magnitude = magnitude
      self.string = string
    }

    internal func create(sign: BigIntPrototype.Sign = .positive) -> BigInt {
      let proto = BigIntPrototype(sign, magnitude: magnitude)
      return proto.create()
    }
  }
}
